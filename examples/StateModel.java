// Generated by state_enforcer (https://github.com/petrs/state_enforcer) 
package yourpackage;

import javacard.framework.CardRuntimeException;

public class StateModel {

    public static final short SW_FUNCTINNOTALLOWED                      = (short) 0x9AF0;
    public static final short SW_UNKNOWNSTATE                           = (short) 0x9AF1;
    public static final short SW_UNKNOWNFUNCTION                        = (short) 0x9AF2;
    public static final short SW_INCORRECTSTATETRANSITION               = (short) 0x9AF3;


    // States constants
    public static final short STATE_UNSPECIFIED                         = (short) 0xF0F0;
    public static final short CHANNEL_NONE                              = (short) 0x75DB; // 0111010111011011
    public static final short SECURE_CHANNEL_ESTABLISHED                = (short) 0x51ED; // 0101000111101101
    public static final short STATE_APPLET_UPLOADED                     = (short) 0x546E; // 0101010001101110
    public static final short STATE_CARD_BLOCKED                        = (short) 0x4379; // 0100001101111001
    public static final short STATE_INSTALLED                           = (short) 0xE822; // 1110100000100010
    public static final short STATE_KEYPAIR_GENERATED                   = (short) 0x89E5; // 1000100111100101
    public static final short STATE_USER_AUTHENTICATED                  = (short) 0xD67C; // 1101011001111100

    // Functions constants
    public static final short FNC_blockCard                             = (short) 0x1000; // 0001000000000000
    public static final short FNC_generateKeyPair                       = (short) 0x2000; // 0010000000000000
    public static final short FNC_getVersion                            = (short) 0x3000; // 0011000000000000
    public static final short FNC_install                               = (short) 0x4000; // 0100000000000000
    public static final short FNC_reset                                 = (short) 0x5000; // 0101000000000000
    public static final short FNC_sign                                  = (short) 0x6000; // 0110000000000000
    public static final short FNC_verifyPIN                             = (short) 0x7000; // 0111000000000000


    private short STATE_CURRENT = STATE_UNSPECIFIED;
    private short STATE_PREVIOUS = STATE_UNSPECIFIED;
    private short STATE_SECONDARY = STATE_UNSPECIFIED;

    public StateModel(short startState) {
        STATE_CURRENT = startState;
        STATE_PREVIOUS = startState;
    }

    public void checkAllowedFunction(short requestedFnc) {
        // Check allowed function in current state
        checkAllowedFunction(requestedFnc, STATE_CURRENT);
        // // Check secondary state (if required)
        checkAllowedFunctionSecondary(requestedFnc, STATE_SECONDARY);
    }

    public short changeState(short newState) {
        short prevState = STATE_CURRENT;
        STATE_CURRENT = changeState(STATE_CURRENT, newState);
        STATE_PREVIOUS = prevState;
        return STATE_CURRENT;
    }
    /** WARNING: this function forces new state despite the state model.**/ 
    public short forceChangeState(short newState) {
        STATE_PREVIOUS = STATE_CURRENT;
        STATE_CURRENT = newState;
        return STATE_CURRENT;
    }
    public short setSecondaryState(short newSecondaryState) {
        STATE_SECONDARY = newSecondaryState;
        return STATE_SECONDARY;
    }

    public short getState() {
        return STATE_CURRENT;
    }

    public short getPreviousState() {
        return STATE_PREVIOUS;
    }

    private static void checkAllowedFunction(short requestedFnc, short currentState) {
        // Check for functions which can be called from any state
        switch (requestedFnc) {
            // case FNC_someFunction:  return;    // enable if FNC_someFunction can be called from any state (typical for cleaning instructions)
            case FNC_blockCard:  return;
            case FNC_getVersion:  return;
        }

        // Check if function can be called from current state
        switch (currentState) {
            case STATE_APPLET_UPLOADED:
                if (requestedFnc == FNC_install) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            case STATE_INSTALLED:
                if (requestedFnc == FNC_blockCard) return;
                if (requestedFnc == FNC_generateKeyPair) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            case STATE_KEYPAIR_GENERATED:
                if (requestedFnc == FNC_blockCard) return;
                if (requestedFnc == FNC_verifyPIN) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            case STATE_USER_AUTHENTICATED:
                if (requestedFnc == FNC_blockCard) return;
                if (requestedFnc == FNC_reset) return;
                if (requestedFnc == FNC_sign) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            default:
                CardRuntimeException.throwIt(SW_UNKNOWNSTATE);
                break;
       }
    }

    private static void checkAllowedFunctionSecondary(short requestedFnc, short currentSecondaryState) {
        // Check for functions which can be called from any state
        switch (requestedFnc) {
            // case FNC_someFunction:  return;    // enable if FNC_someFunction can be called from any state (typical for cleaning instructions)
            case FNC_blockCard:  return;
            case FNC_getVersion:  return;
        }

        // Check if function can be called from current state
        switch (currentSecondaryState) {
            case CHANNEL_NONE:
                if (requestedFnc == FNC_blockCard) return;
                if (requestedFnc == FNC_install) return;
                if (requestedFnc == FNC_reset) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            case SECURE_CHANNEL_ESTABLISHED:
                if (requestedFnc == FNC_generateKeyPair) return;
                if (requestedFnc == FNC_sign) return;
                if (requestedFnc == FNC_verifyPIN) return;
                CardRuntimeException.throwIt(SW_FUNCTINNOTALLOWED); // if reached, function is not allowed in given state
                break;
            default:
                CardRuntimeException.throwIt(SW_UNKNOWNSTATE);
                break;
       }
    }

    private static short changeState(short currentState, short newState) {
        // Check for states which can be reached from any other state (typically some "cleaning" state)
        switch (newState) {
            //case STATE_ALWAYS_REACHABLE: return newState;
            case STATE_CARD_BLOCKED: return newState;
        }

        switch (currentState) {
            case STATE_APPLET_UPLOADED:
                if (newState == STATE_INSTALLED) return newState;
                CardRuntimeException.throwIt(SW_INCORRECTSTATETRANSITION); // if reached, transition is not allowed
                break;
            case STATE_INSTALLED:
                if (newState == STATE_CARD_BLOCKED) return newState;
                if (newState == STATE_KEYPAIR_GENERATED) return newState;
                CardRuntimeException.throwIt(SW_INCORRECTSTATETRANSITION); // if reached, transition is not allowed
                break;
            case STATE_KEYPAIR_GENERATED:
                if (newState == STATE_CARD_BLOCKED) return newState;
                if (newState == STATE_USER_AUTHENTICATED) return newState;
                CardRuntimeException.throwIt(SW_INCORRECTSTATETRANSITION); // if reached, transition is not allowed
                break;
            case STATE_USER_AUTHENTICATED:
                if (newState == STATE_CARD_BLOCKED) return newState;
                if (newState == STATE_KEYPAIR_GENERATED) return newState;
                if (newState == STATE_USER_AUTHENTICATED) return newState;
                CardRuntimeException.throwIt(SW_INCORRECTSTATETRANSITION); // if reached, transition is not allowed
                break;
            default:
                CardRuntimeException.throwIt(SW_UNKNOWNSTATE);
                break;
       }
       CardRuntimeException.throwIt(SW_INCORRECTSTATETRANSITION); // if reached, transition is not allowed
       return newState;
    }

}
